\chapter{Implementaci\'on}\label{implementacion}

\section{Entorno de desarrollo}

\figura{0.25}{img/cap6/vscode.png}{Logotipo Visual Studio Code}{fig:vscode}{}
El entorno de desarrollo utilizado para estra proyecto ha sido Microsoft Visual Studio Code, ya que es un IDE bastante versátil que soporta una gran variedad de lenguajes y que, al ser de código abierto, presenta la posibilidad de instalar plugins creados por la comunidad para obtener funcionalidades útiles para cualquier tipo de lenguaje. Dado que vamos a trabajar con Angular, con la instalación de un paquete de plugins de Angular hemos podido trabajar de forma bastante cómoda y sin ningún problema.\\

Además, ofrece soporte para Git, de forma que se pueden realizar operaciones en el repositorio de forma bastante sencilla, así como gestionar lo posibles errores que puedan surgir mediante la misma interfaz, por lo que resulta bastante cómodo.\\

La principal ventaja de Visual Studio Code es que, al ser un IDE universal, contamos con varias funciones generales de los IDE (debug, consola de comandos) pero aplicado a una gran variedad de lenguajes, de forma que con el simple hecho de tenerlo instalado ya se puede comenzar a trabajar (incluso sin la necesidad de plugins, aunque no es recomendable). Es por esto que con el simple hecho de disponer del IDE y descargar un par de plugins, ya se puede trabajar de forma cómoda, y además se puede adaptar de manera sorprendente ya que, si en algún momento hay que trabajar con otro lenguaje, se puede realizar perfectamente sin tener que descargar otro IDE. Directamente desde Visual Studio Code y con algun plugin extra, ya se puede incorporar el nuevo lenguaje y trabajar de forma cómoda con ambos, lo cual centraliza el trabajo en una misma aplicación y resulta más eficiente.\\

\section{Tecnolog\'ias utilizadas}

La idea principal de este proyecto era usar Angular como tecnología para el front-end por las razones ya explicadas anteriormente. Las demás tecnologías que fueramos a usar no iban a tener tanto peso para nosotros como lo iba a tener esta, por lo que ibamos con la mente abierta dispuestos a usar la tecnología que, además de adaptarse bien a nuestro proyecto, fuera compatible con Angular. Al principio, pensamos en usar una base de Spring para el back-end, ya que es un framework que hemos visto en la carrera y además hemos adquirido experiencia en Java durante todo la carrera, pero debido a que no sabíamos nada sobre el funcionamiento de Angular (y todo lo que puede llegar a abarcar), pensamos que el peso de la aplicación se la llevaría el back-end (en Spring al principio). Sin embargo, una vez aprendimos y nos pusimos a dar nuestros primeros pasos en el framework, descubrimos que se puede realizar la gran mayoría de funcionalidades de la aplicación en Angular.\\

Además luego llegó la hora de conectar el proyecto en Angular con la base de datos. Estábamos acostumbrados a Spring, que realiza toda la gestión de base de datos por detrás en el mismo framework y tan solo es necesario inicializar los repositorios con las querys, así como las beans para popular la base de datos. Sin embargo, al estar trabajando con Angular, tuvimos que buscar información sobre como realizar esta conexión y descubrimos que se podía conectar a una base de datos gestionada mediante PHP con una simple petición HTTP al archivo que realizase la conexión y las operaciones oportunas. Esta idea nos gustó bastante ya que, no solo tendríamos que usar otro lenguaje (por lo que aprendemos más), sino que además podíamos utilizar la conexión con la base de datos a modo de API, haciendo peticiones HTTP desde Angular al correspondiente archivo PHP, el cual se encarga de abrir la conexión con la base de datos, realizar la consulta oportuna, y devolver los datos, los cuales Angular se encarga de recoger, transformarlos en caso de ser necesario, y finalmente, mostrarlos.\\

Es por esto que decidimos entonces usar XAMPP, ya que ofrece un servidor de Apache (en el cual se ejecutarían los archivos PHP que se encargasen de conectarse con la base de datos) así como una base de datos de MariaDatabase. Esto nos vino particularmente bien ya que en otras asignaturas habíamos usado XAMPP, y no solo eso sino que la base de datos de MariaDatabase esta basada en MySQL, que es el lenguaje que hemos dado durante toda la carrera, por lo que al estar trabajando ya con dos lenguajes que no conocemos del todo, uno familiar se recibe bastante bien.\\

Una vez montada la estructura de la base de datos y habiendo probado ya el funcionamiento de Angular y todo su alcance, nos dimos cuenta de que el back-end de Spring que habíamos pensado no era para nada necesario, ya que toda la lógica se realiza a través de este framework y las operaciones para obtener datos de la base de datos las íbamos a realizar con PHP, por lo que al final se descartó la idea de usar Spring como framework para el back-end ya que contábamos con todo lo que necesitábamos con la estructura que disponíamos.\\

\clearpage

\subsection{Angular}

\figura{0.4}{img/cap6/angular.png}{Logotipo Angular}{fig:angular}{}
Angular es un framework para aplicaciones web desarrollado en TypeScript de código abierto que suele ser utilizado para la creación de aplicaciones web de una sola página (SPA), además de seguir el diseño Modelo-Vista-Controlador (MVC).\\

Angular funciona mediante componentes, los cuales disponen de sus respectivas variables y métodos que se encargan de realizar la lógica, así como de operar con su vista asociada. De esta forma, obtenemos pequeños paquetes de código, cada uno con su vista y su lógica. Podría explicarse como si de un puzzle se tratase, pero con muchas posibles soluciones, siendo cada pieza un componente con su vista, sus variables y métodos. Cada pieza es funcional por si misma, pero el objetivo es juntarlos con otros componentes para obtener la aplicación (o vista) completa.\\

Además de ser una forma bastante interesante de desarrollar una aplicación, es una muy buena forma de evitar la repetición de código, ya que si se necesita reusar un componente es tan fácil como importarlo y se encuentra listo. De la misma forma, se trabaja con servicios, directivas y etiquetas que pueden ser reutilizadas, reduciendo así la carga de trabajo considerablemente y aumentando la limpieza del código.\\

Además, una vez se esté ejecutando la aplicación, esta se actualiza con los nuevos cambios que se realicen, algo que resulta bastante cómodo a la hora de realizar algunas pruebas dado que no hay que estar ejecutando constantemente la aplicación.\\

\clearpage

\subsection{XAMPP y Apache}

\figura{0.6}{img/cap6/xampp.png}{Logotipo XAMPP}{fig:xampp}{}
XAMPP es un paquete de software libre que consiste en el sistema de gestión de bases de datos de MySQL, el servidor web Apache y los intérpretes para PHP y Perl.\\

Es una opción bastante buena para nuestro proyecto ya que resulta bastante sencillo de usar y ademas nos proporciona tanto el servidor web como la base de datos y el interprete para PHP, todo desde una misma aplicación.\\

\figura{0.7}{img/cap6/apache.png}{Logotipo Servidor Web Apache}{fig:apache}{}
El servidor web de Apache es un servidor HTTP de código abierto multiplataforma con una arquitectura basada en módulos. Tiene una sección base que actúa como núcleo, y a esta base se le adjuntan módulos que aportan funciones básicas para el servidor web. Además, existen módulos externos para ampliar su funcionalidad, ya sea ofreciendo soporte para distintos lenguajes (Perl, Python, PHP y Ruby entre otros) u ofreciendo otras funciones como llevar un control del tráfico web.\\

\clearpage

\subsection{PHP}
\figura{0.4}{img/cap6/php.png}{Logotipo PHP}{fig:php}{}

PHP es un lenguaje de programación libre especialmente adaptado para el desarrollo web y está orientado al desarrollo de aplicaciones web dinámicas con acceso a información almacenada en una base de datos. Funciona del lado del servidor, por lo que el código es invisible al navegador y al cliente, ya que es el servidor el encargado de ejecutar el código y enviar el resultado  HTML al navegador.\\

El código suele ser procesado en un servidor web por un intérprete PHP implementado como un módulo, y el resultado es representado mediante una petición HTTP. Es bastante versátil ya que puede ser desplegado en la mayoría de servidores web y en todos los sistemas operativos y plataformas sin coste alguno. Gracias a que es libre y a su flexibilidad, es uno de los lenguajes mas populares como base para las aplicaciones web.\\

Su alcance es bastante amplio, ya que puede utilizarse insertando su código en archivos HTML, como para operar con bases de datos o incluso actuar como servicio REST. Es por esto que posee gran capacidad de conexión con la mayoría de motores de base de datos actuales (especialmente con MySQL y PostgreSQL).\\

\clearpage

\subsection{MariaDB y MySQL}

\figura{0.4}{img/cap6/mariadb.png}{Logotipo MariaDatabase}{fig:mariadb}{}

MariaDB es un sistema de gestión de bases de datos derivado de MySQL con licencia GPL. Tiene una alta compatibilidad con MySQL (posee las mismas órdenes, interfaces, API y bibliotecas).\\

\figura{0.4}{img/cap6/mysql.png}{Logotipo MySQL}{fig:mysql}{}

Respecto a MySQL, es un sistema de gestión de base de datos relacional considerada la base de datos de código abierto más popular del mundo. Si MariaDB era un sistema derivado con licencia GPL, MySQL está desarrollado bajo licencia comercial por parte de Oracle.\\

Su uso principal es orientado a aplicaciones web debido a la rapidez que posee a la hora de la lectura de datos. Además, al ser tan popular nos garantiza una gran base de información sobre posibles errores que podamos tener.\\

\clearpage

\subsection{Git}

\figura{0.4}{img/cap6/git.png}{Logotipo Git}{fig:git}{}

Git es un software de control de versiones. Su propósito es llevar registro de los cambios en archivos, incluyendo la coordinación del trabajo que se realiza sobre archivos compartidos entre varias personas. A raíz de este software han surgido plataformas como GitHub o GitDesktop, todo enfocado a la gestión visual y sencilla de las funcionalidades que ofrece Git, así como el alojamiento de proyectos que utilicen dicho sistema de control de versiones.\\

Es uno de los software de control de versiones más populares, lo que ha provocado que muchas aplicaciones ofrezcan compatibilidad con Git, como puede ser Microsoft Visual Studio Code o Eclipse IDE por ejemplo.\\

Como ya se ha comentado, a raiz de Git nació GitHub, siendo también de las plataformas más populares para el alojamiento de proyectos y colaboración simultánea en los mismos. GitHub ofrece desde su servicio básico de alojar proyectos, hasta wikis por cada proyecto, tableros estilo Kanban, gráficas del trabajo y gran cantidad de adiciones para facilitar el trabajo colaborativo en dichos proyectos.\\

Además existen plugins que añaden funcionalidades a la plataforma o que la integran en otras aplicaciones para que su uso esté mas centralizado y sea más cómodo.\\

\clearpage

\section{Dificultades encontradas y soluciones propuestas}

Como es común en todos los proyectos, a medida que se ha ido avanzando en el desarrollo nos hemos ido encontrado con varios obstáculos (unos más grandes que otros) que nos han obligado a desviarnos un poco y buscar soluciones para poder continuar. A continuación se encuentran los obstáculos más significativos y cómo los hemos ido resolviendo:

\subsection{It. 3 - Perfil}

Esta ha sido la primera iteración en la que hemos empezado a programar y hemos desarrollado features. Al principio, dado que íbamos a trabajar con una API \citep{acnhapi} de la que sacaríamos todos los datos, pensamos que el perfil del usuario, así como las distintas funciones que habían dentro de este, no resultarían un gran trabajo ya que trataría más de consumir información y que, por lo tanto, sería un buen comienzo para empezar a iniciarnos en Angular.\\

Sin embargo, cuando nos pusimos a desarrollar código, vimos que no era tan simple y que todo lo que pensábamos que sería consumir información, eran en realidad features que había que realizar, con sus respectivos servicios, clases y lógica, ya que necesitábamos almacenar dicha información relacionándola con el usuario. Esto hizo que se aumentara bastante la carga de trabajo, así que para no cargarnos mucho en esta primera iteración de desarrollo, decidimos dejar la implementación de la API para el siguiente sprint (asi como la realización de los tests, ya que no tiene sentido desarrollar unos tests para features que no estan completas).\\

De este modo, aunque algo más laborioso de lo que se pensó en un principio, pudimos realizar un sprint de introducción al lenguaje (del que hemos aprendido bastante) que nos sirve como base para los siguientes sprint, ya que con cada feature que hemos ido desarrollando, hemos descubierto más y más sobre el framework, adquiriendo así las nociones necesarias para avanzar de forma eficiente.

\subsection{It. 3 - Mantener sesiones}

En esta iteración decidimos repartir las tareas de forma que uno de nosotros empezara implementando todo lo relacionado con el registro y el inicio de sesión mientras que el otro se iba encargando de otras tareas, en este caso, de las funciones dentro del perfil.\\

El problema comenzó con lo mencionado en el punto anterior: se combinó el aumento de carga de trabajo con las dificultades que encontramos a la hora de mantener una sesión en la página, ya que era necesario para la mayoría de tareas del perfil. Además, como el servidor de Apache donde se encuentra la base de datos y el servidor de Node.JS en el que se ejecuta Angular están localizados en puertos distintos, no se podía realizar una sesión de forma normal (al igual que muchas otras funciones de PHP como acceder a los datos de una operación POST mediante la variable por defecto de PHP).\\

Esto ocasionó que tuviéramos que dar un rodeo buscando posibles soluciones hasta dar con la actual, que se basa en almacenar un código de verificación que se borre exclusivamente al cerrar sesión, de forma que se mantiene la sesión mientras el usuario tenga asignado un código de verificación que no sea nulo. Debido a este rodeo y al tiempo que llevó tanto encontrar la solución como su implementación, hubo cierta dependencia entre tareas, lo que ocasionó un ligero aumento del tiempo inicial pensado para dichas tareas.

\subsection{It. 3 - Features del perfil}

En la feature de ``Mis vecinos``, teníamos que calcular el porcentaje que tiene cada vecino de mudarse de isla, dependiendo de la amistad que tenga con el jugador y de ciertos parámetros que hayan podido ocurrir. Este algoritmo pensábamos que ya lo habrían sacado del juego y podríamos acceder a él, sin embargo no fue así.\\

Dado que no se había publicado el algoritmo, tuvimos que realizar cierta investigación para dar con la fórmula que calcula dicha probabilidad y acto seguido, implementar nosotros el algoritmo (Agradecimientos al usuario de Twitter \textit{Ninji} que publicó la lógica y las matemáticas que sigue el juego para calcular la probabilidad de mudanza, información a partir de la cual pudimos implementar el algoritmo).\\

Respecto a la feature de ``Colecciones Especiales``, dado que no nos habíamos informado tanto como debíamos sobre la API que íbamos a usar, descubrimos que dicha API no tiene ningún método de filtro mas que obtener objetos por su id, por lo que nos obligaba a hacer una petición con todos los objetos e ir filtrando por ``fuente`` (colección) para seleccionar los que nos interesaban. Esto era posible pero suponía un gran coste computacional, especialmente si lo implementamos de forma que cualquier usuario pueda hacer dicha petición.\\

Ante este problema, dimos con la idea de crear un usuario administrador (el cual no había hecho falta hasta ahora) que pudiera ejecutar dicha petición para actualizar el catalogo de colecciones, de forma que con una sola petición por parte del administrador, se actualizan los items disponibles para los usuarios, de forma que estos acceden a una tabla de la base de datos con datos mínimos (fuente e id).\\

De esta forma, aunque guardamos algunos datos en la base de datos, nos ahorramos tanto el realizar peticiones de forma constante en la que recibimos cientos de objetos, como el filtrarlos para poder obtener los deseados, aumentando así la velocidad de respuesta.

\subsection{It. 4 - API incompleta}

En la iteración 4 debíamos hacer un repaso por las features realizadas en la iteración anterior de forma que añadiésemos todo lo necesario relacionado con la API \citep{acnhapi} que íbamos a utilizar para acceder tanto a imágenes como a datos del juego.\\

Sin embargo, una vez nos pusimos a implementar la API, nos dimos cuenta de que, aunque bastante completa para algunos aspectos del juego, para otros no estaba tan completa y carecía de muchos datos que necesitábamos. Además solo implementaba métodos para obtener o todo el listado de datos, o uno solo (mediante su ID), pero en ningún momento nos dejaba filtrar, por lo que iba a ser un trabajo que íbamos a tener que realizar a mano y que además sería bastante costoso computacionalmente hablando.\\

Es por eso que realizamos otra búsqueda en la web para encontrar una solución distinta que nos proporcionase todo lo que necesitábamos. Primero encontramos otra API \citep{nookipediaapi} que, aunque disponía de más métodos y alguna información que nos podía resultar útil, estaba aun a mitad de desarrollo, por lo que también estaba algo incompleta. Se pensó en implementar ambas APIs, pero el resultado no era lo que buscábamos, era una solución algo compleja y no nos convencía del todo, pero parecía ser la única opción.\\

Sin embargo, tras seguir buscando encontramos una librería \citep{acnhnpm} que se podía instalar directamente en Angular que disponía de toda la información que necesitábamos, así como ciertas traducciones e imágenes, por lo que decidimos usar esta librería ya que, no solo nos daba todo lo que necesitábamos sino que ademas su uso era extremadamente sencillo. 

\subsection{It. 5 - Código reciclado}

En la iteración 5 introdujimos la calculadora de nabos y el calendario de eventos entre otras features. Para la calculadora necesitábamos el algoritmo que calculaba los precios establecidos en el juego. Dicho algoritmo había sido datamineado por un usuario ya mencionado anteriormente en esta memoria \citep{nabosninji}.\\

El problema surge a raíz de que dicho algoritmo, que se encuentra subido en la plataforma GitHub, estaba para otro lenguaje distinto al de nuestro proyecto, por lo que no pudimos usarlo directamente. Al principio consideramos intentar adaptarlo, pero era tan extenso y complejo que no merecía la pena dedicarle tantas horas a esa tarea, por lo que optamos por otra solución.\\

De entre varias webs que ya disponen de esta herramienta, hay una \citep{turnipprophet} que está realizada al completo en JavaScript, por lo que se realiza todo el trabajo por parte del cliente. Investigando descubrimos que dicho código también se encontraba en GitHub bajo la licencia de Apache 2.0, la cual nos permite usar el código mientras que cumplamos ciertas reglas, por lo que decidimos usar lo que necesitáramos del código, ya que no solo calcula y predice los precios futuros, sino que genera una tabla de precios bastante útil para el usuario.\\

El problema es que, al ser código reciclado y además en ficheros JavaScript, nos llevamos un tiempo haciendo pruebas para comprender el funcionamiento y la integración con nuestra aplicación, ya que hasta ahora habíamos estado trabajando con los ficheros TypeScript de Angular y no habíamos integrado ningún fichero JS externo. Esto conllevó varias pruebas hasta que finalmente conseguimos realizar la integración de forma satisfactoria, pero a cambio de cierto tiempo empleado en búsqueda de posibles soluciones, comprensión del código e integración con nuestra aplicación.\\

Otro problema que surge a raíz de lo mismo fue que tanto para la calculadora de nabos como para el calendario (especialmente para éste último) tuvimos bastante limitado la personalización \citep{angularcalendar}. El calendario hace uso de una aplicación de Angular ya creada que nos ofrece un calendario con posibilidad de añadir nuestros propios eventos, así como muchas más posibilidades. El problema es que nuestro calendario es mucho más básico ya que lo único que busca es mostrar información de eventos preestablecidos, por lo que era necesario modificarlo para adaptarlo a nuestra aplicación.\\

Pero claro, aunque estaba preparado para poder personalizarlo bastante, había que realizar muchos cambios, por lo que al igual que nos ocurrió con la calculadora de nabos, tuvimos que dedicarle algo de tiempo a comprender como funcionaba y más aún a realizar los cambios. Lo malo es que el calendario se generaba automáticamente, es decir, no disponíamos de todo el HTML desde el inicio, por lo que los cambios para añadir o quitar elementos tuvimos que realizarlos mediante CSS y JS, lo que se nos complicó bastante ya que era código reciclado y teníamos que tener cuidado al operar para no destrozar el funcionamiento ni afectar a más de lo que queríamos.\\

Dicho esto, pudimos modificarlo de forma satisfactoria tras dedicarle algo de tiempo. Aunque no obtuvimos el resultado que queríamos al 100\%, si que nos acercamos bastante a lo que buscábamos, por lo que nos ahorró bastante más tiempo que si lo hubiéramos implementado desde 0.

\subsection{It. 5 - Feature demasiado compleja}

Una de las features que queríamos añadir en este sprint era el "Probador de ropa", que consistía que una página donde el usuario pudiera crear un personaje del juego a su gusto, así como vestirlo con las distintas prendas del juego para, de esta forma, poder probarse distintos conjuntos sin tener que esperar a que apareciesen en la tienda del juego o sin tener que gastarse mucho dinero en varias prendas de ropa.\\

En un principio esta herramienta se planteó de forma que la prenda que eligiese el usuario iría superpuesta a la imagen del personaje en la zona correspondiente (por ejemplo si es una camiseta, iría en el torso). Esta idea no estaba exenta de fallos ya que dependíamos de la postura de las prendas de ropa (la gran mayoría vienen en "T-pose") y había varias, especialmente aquellas de manga larga, que por ejemplo tenían una manga doblada, lo que nos impedía representar por completo la ilusión de que el personaje llevaba la prenda.\\

Aun así, no eran muchas prendas, por lo que al ser una herramienta tan interesante decidimos seguir adelante e incluirla en el planteamiento. Sin embargo, al llegar a este sprint donde tocaba su implementación, fue cuestión de poco tiempo el darnos cuenta de que era inviable. No solo es que hubiese algunas prendas con una manga doblada, sino que había tipos de prenda completos cuya imagen no podíamos representarlo como si el personaje estuviera llevándola puesta (por ejemplo, los zapatos se ven desde una posición cenital y los calcetines se muestan en pareja, por lo que no hay manera posible de representarlos).\\

Tras investigar todo lo posible, vimos que eran tantos los fallos visuales que se cometerían que no rentaba realizar una herramienta tan completa para obtener un funcionamiento tan mediocre. Intentamos optar por buscar alguna herramienta del estilo ya realizada o algo que pudiésemos utilizar para intentar salvar la herramienta, pero por desgracia no dimos con nada por lo que optamos por desechar la funcionalidad.\\

Finalmente intentamos buscar otra feature para reemplazar a ésta, pero ya no quedaba demasiado por añadirle a la página que le resultara útil al usuario más que párrafos y párrafos de información, que aunque útiles, no es lo que busca nuestra página, por lo que optamos por no realizar ninguna y dedicar el tiempo de implementación de dicha herramienta tanto al apartado visual de la página como a pulirla todo lo posible.\\

Cabe decir que la implementación del probador de ropa es posible realizarla, solo que para obtener un buen resultado habría que dedicarle horas y horas de recolección de imágenes del juego, así como de edición manual de las mismas mediante un programa de edición fotográfica para que se adapten al resultado que buscamos. Sin embargo, no solo es un trabajo manual (y por lo tanto, va en contra de lo que queremos ya que buscamos hacerlo todo de la forma más programática posible) sino que además sería demasiado extenso y en cuestión de trabajo/tiempo no podíamos dedicárselo.

\subsection{It. 6 - Despliegue}

Uno de los últimos problemas que hemos tenido ha sido el despliegue online de la aplicación. Dada la combinación que hemos usado de Angular + PHP + MariaDB, necesitábamos desplegar la aplicación en dos servidores distintos: uno para el front (Angular) y otro para el back (PHP). Además, también necesitábamos una base de datos desplegada para realizar las consultas, que fue lo que provocó el principal problema.\\

Vimos que habían varios servicios online de alojamiento de bases de datos (en particular, de MariaDB con PhpMyAdmin, que era lo que necesitábamos), y además eran gratuitos, por lo que decidimos optar por uno de estos. Sin embargo, al ser gratuito tenía que tener algunos límites, siendo uno de estos la imposibilidad de crear eventos SQL.\\

Esto nos suponía un leve problema ya que las tareas del perfil se desactivan diariamente mediante un evento SQL, por lo que si usábamos esta opción, no dispondríamos de dicha función en la aplicación. Al ver esto, buscamos otros servicios de alojamiento gratuito de bases de datos, pero no solo seguían teniendo el mismo límite, sino que además eran mas restrictivos en comparación con la que pensábamos usar.\\

Sin embargo, este problema puede ser solucionado de varias formas: o bien alojando nuestra BBDD en un servicio que permita la creación de eventos (aunque sería un servicio de pago); o bien optando por reiniciar las tareas de otra forma distinta en el código (aunque no lo consideramos óptimo ya que los eventos SQL están precisamente diseñados para realizar este tipo de tareas).\\

Es por eso que, siendo lo ideal resolverlo mediante la primera opción (ya que en un despliegue real de la aplicación necesitaríamos un servicio con mayor número de consultas y otras características, entre las cuales vendría el servicio de creación de eventos), hemos decidido usar esta opción gratuita de alojamiento y prescindir de dicho evento (especialmente, tratándose solo de un evento cuya función equivale a hacer click en el botón de la tarea y apenas va a ser notable).\\

\subsection{It. 6 - CORS Policy}

La política de CORS ha ocasinado problemas durante gran parte del desarrollo de la aplicación. Sin embargo, haciendo algunos ajustes en las cabeceras HTTP conseguimos evitar la aparición de más errores mientras que seguíamos desarrollando.\\

El problema vino una vez acabado el desarrollo, cuando nos pusimos a desplegar la aplicación, ya que como necesitamos desplegar en dos aplicaciones diferentes el backend y el frontend, al realizar peticiones entre sí otra vez ocurrían los errores. Esto se debe a que CORS, cuando está en producción, antes de cualquier petición HTTP manda una petición con el método OPTION, para comprobar que es correcta, y una ves recibe una respuesta satisfactoria, manda la petición original.\\

En principio pensábamos que con las cabeceras ya valdría, pero estábamos equivocados ya que, al enviar la primera petición, necesita un parámetro en una de las cabeceras, y dicho parámetro no puede encontrarse en la cabecera de la segunda petición (la original), por lo que no podíamos asignar la misma cabecera a todas las peticiones\\

Sin embargo, tras una intensiva búsqueda en la web, dimos con una librería para Angular que con un par de líneas de código, configuraba automáticamente todo lo respectivo a CORS, y una vez instalado y configurado conseguimos que funcionase sin ningún problema.\\

\subsection{It. 6 - AdBlock}

Aunque no es un problema grave per se, si que es un apunte a tener en cuenta y es que, si el usuario tiene instalado en su navegar algún addon para evitar publicidad, por cómo funcionan estos addons, hay algunas imágenes que no serán visibles, o que se mostrarán con un placeholder, ya que la misma url de la que se obtiene la imagen puede tener unos caracteres determinados que estén en la lista negra del addon y éste proceda a bloquearlo, pensando que se trata de publicidad.\\

Aun así, este problema (que parece afectar exclusivamente a la carga de algunas imágenes) se puede solucionar desactivando dicho addon en la página.\\





	